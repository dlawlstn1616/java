/////////////////////////////
 
자바 언어의 특징

//////////////////////////////

1. 운영체제에 독립적이다.
- 자바 응용 프로그램은 자바 가상 머신(JVM)을 통해서만 통신을 하고 이 JVM이 자바 응용 프로그램으로 부터 전달받은 명령을 운영체제가 이해할 수 있도록 변환시켜줌
- 즉 자바 응용 프로그램은 운영체제에 독립적이고, JVM이 운영체제에 종속적이다.
- 다양한 버전의 JVM으로 운영체제에 맞는 버전을 제공한다.

2. 객체지향언어이다.
- 객체지향개념의 특징인
- 상속
- 캡슐화
- 다형성
이 잘 적용된 순수한 객체지향언어이다.

- 특히 객체지향언어는 재사용성과 유지보수에 용이하다.

3. 배우기 쉽다.

4. 자동 메모리 관리(Garbage Collector가 존재한다).
- 자바로 작성된 프로그램이 실행되면, 자동적으로 garbage collector가 작동해서 메모리를 관리해줌.
- 프로그래머가 수동으로 사용하지 않는 메모리를 체크하고 반환하는 일을 하지 않아도 된다.
- 다만, 자동으로 관리해주는게 다소 비효율적인 면모가 존재한다.

5. 네트워크와 분산처리를 지원한다.
- 인터넷과 대규모 분산환경을 염두에 둔 언어이다.
- 풍부하고 다양한 네트워크 프로그래밍 라이브러리(Java API)를 통해 비교적 짧은 시간에 네트워크 관련 프로그램을 쉽게 개발할 수 있다.

6. 멀티쓰레드를 지원한다.
- 일반적으로 운영체제에 따라 구현하는 방식도, 처리 방식도 다르지만 자바에서 제공되는 멀티쓰레드 프로그램은 시스템과 관계없이 구현가능
- 여러 쓰레드에 대한 스케쥴링은 자바 인터프리터가 담당

7. 동적 로딩(Dynamic Loading)을 지원한다.
- 보통 자바로 작성된 어플리케이션은 여러 클래스로 구성되어 있는데, 동적 로딩을 통해 실행시 모든 클래스가 로딩되지 않고 필요한 시점에
클래스를 로딩하여 사용할 수 있다.
- 일부 클래스가 변경되어도 전체 어플리케이션을 다시 컴파일 하지 않아도 된다.
- 어플리케이션의 변경사항이 발생해도 비교적 적은 작업만으로로 처리할 수 있는 유연한 어플리케이션 작성 가능.



*** 다만 처리속도가 느리다는게 자바의 큰 단점인데 해당 문제점은 JVM의 기술 발달로 인해 점점 해소되고 있는 추세이다.


/////////////////////////////
 
JVM

//////////////////////////////

- 가상머신은 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미이다.
- 자바로 작성된 어플리케이션은 모두 이 가상 머신에서만 실행되기 때문에, 자바 어플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.

Java 어플리케이션

JVM (일반적인 어플리케이션은 해당 단계가 없이 즉시 OS와 통신한다.)

OS(Windows)

컴퓨터(Hardware)


순서로 통신
다만 OS에 맞게 완전히 컴파일 된 것이 아니라 실행시 JVM을 통해 해석(interpret)되는 과정이 있으므로 속도가 느린 단점이 있다.

/////////////////////////////
 
source file & public class name

//////////////////////////////

- src file 이름과 public class의 이름은 동일해야 된다. 이때, 대소문자도 반드시 일치해야 된다. e.g. Hello.java -> public class Hello
- public class가 없을 경우 여러 class 중 하나와 src 파일의 이름이 일치하면 된다.
- 하나의 src file에는 하나의 public class만 존재해야 된다.


/////////////////////////////
 
Main 메서드

//////////////////////////////

- public static void main(String[] args) // main 메서드의 선언부, 자바 인터프리터에 의해 호출될 수 있도록 미리 약속된 부분
					        // String 타입의 배열 args를 선언한 것, String args[]와 동일하다.

- 모든 클래스가 메인 메서드를 가질 필요는 없지만, 하나의 Java 어플리케이션에는 main 메서드를 포함하는 클래스가 반드시 하나는 있어야 한다.
- main 메서드는 자바 어플리케이션의 시작점이므로, main 메서드가 없으면 자바 어플리케이션이 실행될 수 없다.
- 애플릿(applet)이나 서블릿(servlet)은 예외이나, 비슷한 역활을 하는 메서드가 여전히 필요하다.

/////////////////////////////
 
자주 발생하는 에러와 해결방법

//////////////////////////////

1. cannot find symbol 또는 cannot resolve symbol
- 지정된 변수나 메서드를 찾을 수 없다는 뜻
- 선언되지 않은 변수나 메서드를 사용하거나, 이름을 잘못 사용한 경우
- 철자 뿐만 아니라 대소문자에 대해서도 꼼꼼히 확인 필요

2. ';' expected
- 세미콜론이 빠진 경우

3. Exception in thread "main" java.lang.NoSuchMethodError : main
- main 메서드를 찾을 수 없다는 것, 실제로 존재하지 않거나 메서드 도입부인 public static void main (String [] args) 에 오타가 존재하는 경우다.
- args 는 매개변수의 이름이므로 언제든지 다른 이름을 사용할 수 있다.

4. Exception in thread "main" java.lang.NoClassDefFoundError : Hello
- Hello라는 메서드를 찾을 수 없다는 것, 오타를 확인하고 실제로 Hello.class 파일이 생성되었는지 확인한다.

5. illegal start of expression
- 문장의 앞부분이 문법에 맞지 않다는 것, 문장에 문법적 오류가 있다는 것, 괄호나 if문, for문 등 또는 public과 static과 같은 키워드를 잘못 사용했는지 확인.

6. class, interface, or enum expected
- class, interface 또는 enum이 없다는 것, 보통 ' { ',  ' } ' 괄호의 갯수가 일치하지 않을 때 발생한다.


/////////////////////////////
 
자바 프로그램의 실행과정

//////////////////////////////

1. 프로그램의 실행에 필요한 클래스를 로드한다.(Dynamic loading)
2. 클래스파일을 검사한다.(파일형식, 악성코드 체크) - java interpreter??
3. 지정된 클래스에서 main 메서드를 호출한다.

- main 메서드가 처음부터 끝까지 모두 실행되면, 프로그램이 종료되고, 프로그램이 사용한 자원들은 모두 반환된다.
- 멀티쓰레드를 이용하는 경우에는, main 메서드가 종료되어도 다른 쓰레드가 실행중이면 프로그램이 종료되지 않는다.


/////////////////////////////
 
변수

//////////////////////////////

프로그램은 pcb(program control block)에서 stack, data, heap, code로 저장되는데,
stack : function, local variable (크기 가변) - 함수 호출에 따라 크기를 다르게 지정해 줘야대서
data : global variable (크기 고정)
heap : dynamic allocation (크기 가변) - 동적할당 영역이기 때문에 크기가 가변적이다.
code : code (크기 고정)

=> 크기가 가변적인 부분을 관리하는게 중요하다, 즉 function call을 적절히, local variable 크기를 적당히 해서 stack overflow를 예방해야 된다.


- 변수란 단 하나의 값을 저장할 수 있는 메모리상의 공간을 의미한다.
- 우선 변수타입으로 변수를 선언해줘야 한다.
- 변수에 적절한 값을 저장해줘야 되는데, 이러한 과정을 변수 초기화 과정이라고 부른다.

*** 명명규칙
1. 대소문자가 구분되며 길이에 제한이 없다.
2. 예약어를 사용해서는 안 된다.
3. 숫자로 시작해서는 안 된다.
4. 특수문자는 ' _ ' 와 ' $ ' 만을 사용한다.

*** 권장하는 규칙
1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
e.g. lastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 ' _ ' 로 구분한다.
e.g. PI, MAX_NUMBER

/////////////////////////////
 
변수 타입

//////////////////////////////

* 기본형
- boolean (1 byte), char (2 byte), byte (1 byte), short (2 byte), int (4 byte), long (8 byte), float (4 byte), double (8 byte) (8개)
boolean은 논리형, char는 문자형 (유니코드가 2byte 체계), byte short int long은 정수형, float double은 실수형
- 계산을 위한 실제 값을 저장한다.

* 참조형
- 8개의 기본형을 제외한 나머지 타입, 객체의 주소를 저장한다.
- null 또는 객체의 주소(4 byte, 0x0~0xffffffff)를 값으로 가진다.

e.g. Date클래스의 변수를 선언하는 경우 Date today = null 또는 Date today = new Date(); 로 선언한다.


/////////////////////////////
 
변수 형변환 (casting)

//////////////////////////////

- 변수 또는 리터럴의 타입을 다른 타입으로 변환하는 것이다.
e.g. int score = (int)85.4;
- 범위가 큰 자료형에서 범위가 작은 자료형으로 변환은 값의 손실을 야기한다.
- 보통 범위를 넘어선 값은 버려지게 된다.

*** 사칙연산을 진행할 때, int 보다 작은 표현을 가진 자료형들은 int로 변환 후 사칙연산을 진행한다.
    이러한 경우가 아닌 경우, 더 큰 표현의 자료형을 따라간다.


/////////////////////////////
 
연산들

//////////////////////////////

- 기본 연산들을 진행하는데 있어서 int보다 낮은 byte를 가지는 타입들은 int로 계산되고
- 그 외의 상황에서는 더 높은 타입으로 형변환되어 계산된다.


/////////////////////////////
 
배열

//////////////////////////////

- int arr = {1, 2, 3}; 선언과 동시에 초기화를 진행하는 경우
- int arr = new int [] {1, 2, 3}; 이 때는 선언과 초기화를 따로 진행해도 가능하다.

- int add ( int [ ] arr ) {  } 일때는 즉 메서드가 미리 정의되어 있고 해당 메서드를 호출해야 하는 경우
  int result = add ( new int [ ] {  } ) 으로 진행해야된다.


/////////////////////////////
 
객체지향언어

//////////////////////////////

- 기본개념 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'
- 실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현하고 이 가상세계에서 모의실험을
  함으로써 많은 시간과 비용을 절약할 수 있었다.

- 상속
- 캡슐화
- 추상화


- 이점들
1. 코드의 재사용성이 높다
	- 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
	- 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
	- 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
	  코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

*** 가장 큰 장점은 '코드의 재사용성이 높고 유지보수가 용이하다.'


/////////////////////////////
 
클래스와 객체

//////////////////////////////

*** 클래스 : '객체를 정의해놓은 것' 또는 '객체의 설계도 또는 틀'
- 객체를 생성하는데 사용된다.
- 인스턴스화
- 데이터(변수)와 함수의 결합
1. 변수 - 하나의 데이터를 저장할 수 있는 공간
2. 배열 - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 - 데이터와 함수의 결합(구조체 + 함수)

- 사용자정의 타입


*** 객체 : '실제로 존재하는 것'
- 인스턴스화로 인해 만들어진 객체 = 인스턴스
- 속성 : 멤버 변수
- 기능 : 메서드

e.g. class Tv
Tv t; // 먼저 클래스의 객체를 참조하기 위한 참조변수를 선언한다. 해당 과정을 통해 메모리에 참조변수 t를 위한 공간을 만든다.
t = new Tv(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장한다. 만들어진 메모리 공간에 Tv클래서의 인스턴스가 생성된다. 그 공간의 주소가 참조변수 t에 저장된다.



/////////////////////////////
 
변수와 메서드

//////////////////////////////

*** 변수
- 변수의 선언된 위치에 따라 다름
- 클래스 영역
1. 클래스변수 : 멤버변수 중 static이 붙은 것은 클래스변수, 공통된 저장공간을 공유해서 공유변수라고도 한다. 사용할 땐, 클래스이름.클래스변수의 형태로 사용한다.
e.g. Card.length = 100;
2. 인스턴스변수 : 멤버변수 중 static이 붙지 않은 것은 인스턴스변수, 클래스의 인스턴스를 생성할 때 생성, 독립적인 저장공간, 사용할 땐 항상 참조변수.인스턴스변수 로 사용한다
e.g. Card c1 = new Card();
     c1.kind = "Heart"; 

인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로,
항상 공통된 값을 갖는다.

- 클래스 영역 이외의 영역
3. 지역변수 : 멤버변수를 제외한 나머지 모든 변수
e.g. 메서드 영역 (클래스 내부의 메서드라고 할지라도)


*** 메서드
- 어떤 작업을 수행하기 위한 명령문의 집합
- 반복적으로 사용되는 코드를 줄이기 위함
유의점
1. 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다.
2. 반복적으로 수행되어야 하는 여러 문장을 하나의 메서드로 정의해 놓으면 좋다.
3. 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다.

- return 문
 만약 메서드가 리턴타입이 지정이 되어 있고, return 할 값이 있다면, 어떠한 경우에도 return이 작동하도록 코드를 작성해야한다.
 if 문에 return이 들어가있으면 else로 예외처리도 해줘야 오류가 발생하지 않는다.

- 호출 : 참조변수.메서드이름(값1, 값2, . . . )


/////////////////////////////
 
JVM 의 메모리구조

//////////////////////////////

- 3가지 주요영역
1. Method Area
	- 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.
	  이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.
2. Call Stack (호출스택)
	- 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.
	- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
	- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
	- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
	- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
3. Heap
	- 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안
	  지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.


/////////////////////////////
 
클래스메서드(static 메서드)와 인스턴스메서드

//////////////////////////////

*** 클래스메서드
- 클래스변수와 마찬가지로 클래스메서드도 인스턴스(객체) 없이 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출 가능
- 클래스는 '데이터와 데이터에 관련된 메서드의 집합'
- 인스턴스와 관계없는(인스턴스변수나 인스턴스메서드를 사용하지 않는) 메서드를 클래스메서드로 정의한다.

\\ 유의사항
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
	- 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다.
	  그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의해야 한다.
2. 클래스변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
	- static이 붙은 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.
3. 클래스메서드(static메서드)는 인스턴스변수를 사용할 수 없다.
	- 인스턴스변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성 없이 호출가능하므로 클래스메서드가 호출되었을 때 인스턴스가 존재할 수도 있고
	  존재하지 않을 수도 있다. 그래서 클래스메서드에서 인스턴스변수의 사용을 금지한다. 그러나 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나
	  가능하다. 인스턴스변수가 존재한다는 것은 static이 붙은 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.
4. 메서드 내에서 인스턴스변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
	- 메서드의 작업내용 중에서 인스턴스변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필요로 하지 않는다면 static을 붙이자.
	  메서드 호출시간이 짧아지기 때문에 효율이 높아진다.
	- static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.

*** 인스턴스 메서드
- 인스턴스변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스변수를 필요로 하는 메서드이다.

\\\\
- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면 static을 붙여서 클래스변수로 만들어 준다.
- 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 대해서 static을 붙일 것을 고려한다. 


/////////////////////////////
 
클래스멤버와 인스턴스멤버간의 참조와 호출

//////////////////////////////

- 위에서 언급했던대로, 클래스멤버는 인스턴스멤버를 호출할 수 없지만, 그 반대는 가능하다. 인스턴스멤버는 반드시 인스턴스를 생성한 후에만 참조 또는 호출 가능
- 하지만 인스턴스멤버들 끼리는 호출에 문제가 없다. 이미 하나의 인스턴스멤버가 존재한다면, 다른 인스턴스멤버들도 전부 존재하기 때문이다.



/////////////////////////////
 
메서드 오버로딩(method overloading)

//////////////////////////////

- 메서드 오버로딩 : 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서
			메서드를 정의할 수 있다.

\\ 오버로딩의 조건
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다.
(리턴타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.)


/////////////////////////////
 
생성자(Constructor)

//////////////////////////////

- 생성자 : 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
- 변수의 초기화 작업에 주로 사용, 인스턴스 생성 시에 실행되어야 할 적업을 위해서 사용
- 메서드 처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 리턴 값이 없다.

\\ 생성자의 조건
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.

*** 주의 : 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다.

e.g.
Card c = new Card();
1. 연산자 new에 의해서 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

- 클래스에 정의된 생성자가 하나도 없을 경우에는 기본 생성자가 컴파일러에 의해서 추가된다.
e.g.
class Data1 {
	int value;
}
일때는 Data1()이라는 기본 생성자가 자동으로 추가된다.

- 생성자에서 다른 생성자 호출하는데는 this(), this를 사용한다.
\\ 조건
1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
3. 인스턴스변수에만 접근 가능하다. 클래스변수에는 접근 불가

- 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조 변수 this가 지역변수로 숨겨진 채로 존재
this - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
this(), this(매개변수) - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.	

\\ 인스턴스 생성시 2가지 사항
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?



/////////////////////////////
 
변수의 초기화

//////////////////////////////

\\ 멤버변수 초기화 방법
1. 명시적 초기화(explicit initialization)
- 변수를 선언과 동시에 초기화 하는 것, 가장 간단하고 명료하지만 복잡한 초기화 작업에는 초기화 블럭 및 생성자를 사용한다.

2. 생성자 (constructor)

3. 초기화 블럭 (initialization block)
- 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용.
- 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용.
e.g.
class InitBlock {
	static { /* 클래스 초기화 블럭 자리, 클래스가 메모리에 처음 로딩될 때 한번만 수행 */}
	
	{ /* 인스턴스 초기화 블럭 자리, 인스턴스를 생성할 때마다 수행, 보통 생성자를 사용하기 때문에 사용하지 않지만 생성자마다 실행되는 코드가 있다면 사용 
	     코드의 중복을 제거함으로서 신뢰성을 높여 주고, 오류의 발생 가능성을 줄여주는 장점 존재 */}
	{ System.out.println("Car인스턴스가 생성되었습니다."); }
	Car() {
	}
	Car( . . . ){
	
	}
}

클래스변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다
인스턴스변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.

클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자


/////////////////////////////
 
상속

//////////////////////////////

- 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
	-> 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고, 코드를 공통적으로 관리 == 코드의 추가 및 변경이 매우 용이
	-> 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.
e.g.
class Child extends Parent {
	. . .
}
extends를 사용해서 부모 클래스를 상속받는다.

조상 클래스 - 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
자손 클래스 - 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스

조상클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 그 반대는 아무런 영향을 주지 못한다.
